// Code generated by Wire protocol buffer compiler, do not edit.
// Source: buf.connect.demo.eliza.v1.ElizaService in simple.proto
package buf.connect.demo.eliza.v1

import com.squareup.wire.GrpcClient
import com.squareup.wire.GrpcMethod
import com.squareup.wire.GrpcRequestBuilder
import com.squareup.wire.GrpcResponse
import com.squareup.wire.internal.RealGrpcStreamingCall
import com.squareup.wire.internal.grpcResponseToException
import com.squareup.wire.internal.messageSink
import com.squareup.wire.internal.messageSource
import com.squareup.wire.internal.newDuplexRequestBody
import java.io.IOException
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import okhttp3.Call
import okhttp3.Callback

/**
 * ElizaService provides a way to talk to the ELIZA, which is a port of
 * the DOCTOR script for Joseph Weizenbaum's original ELIZA program.
 * Created in the mid-1960s at the MIT Artificial Intelligence Laboratory,
 * ELIZA demonstrates the superficiality of human-computer communication.
 * DOCTOR simulates a psychotherapist, and is commonly found as an Easter
 * egg in emacs distributions.
 */
public class GrpcElizaServiceClient(
  private val client: GrpcClient,
) : ElizaServiceClient {
  /**
   * Converse is a bi-directional streaming request demo. This method should allow for
   * many requests and many responses.
   */
  public override fun Converse(): RealGrpcStreamingCall<ConverseRequest, ConverseResponse> {
    val method = GrpcMethod(
      path = "/buf.connect.demo.eliza.v1.ElizaService/Converse",
      requestAdapter = ConverseRequest.ADAPTER,
      responseAdapter = ConverseResponse.ADAPTER
    )
    return RealGrpcStreamingCall(client, method)
  }

  fun converse(scope: CoroutineScope): Pair<SendChannel<ConverseRequest>, ReceiveChannel<ConverseResponse>> {
    val method = GrpcMethod(
      path = "/buf.connect.demo.eliza.v1.ElizaService/Converse",
      requestAdapter = ConverseRequest.ADAPTER,
      responseAdapter = ConverseResponse.ADAPTER
    )
    val requestChannel = Channel<ConverseRequest>(1)
    val responseChannel = Channel<ConverseResponse>(1)
    val requestBody = newDuplexRequestBody()
    val requestMetadata = emptyMap<String, String>()
    val call = client.client.newCall(
      GrpcRequestBuilder()
        .url(client.baseUrl.resolve(method.path)!!)
        .addHeader("te", "trailers")
        .addHeader("grpc-trace-bin", "")
        .addHeader("grpc-accept-encoding", "gzip")
        .apply {
          if (client.minMessageToCompress < Long.MAX_VALUE) {
            addHeader("grpc-encoding", "gzip")
          }
          for ((key, value) in requestMetadata) {
            addHeader(key, value)
          }
        }
        .tag(GrpcMethod::class.java, method)
        .method("POST", requestBody)
        .build()
    )

    responseChannel.invokeOnClose {
      if (responseChannel.isClosedForReceive) {
        // Short-circuit the request stream if it's still active.
        call.cancel()
        requestChannel.cancel()
      }
    }
    scope.launch(Dispatchers.IO) {
      val requestWriter = requestBody.messageSink(minMessageToCompress = client.minMessageToCompress,
        requestAdapter = method.requestAdapter,
        callForCancel = call
      )
      try {
        requestWriter.use {
          var channelReadFailed = true
          try {
            requestChannel.consumeEach { message ->
              channelReadFailed = false
              requestWriter.write(message)
              channelReadFailed = true
            }
            channelReadFailed = false
          } finally {
            if (channelReadFailed) requestWriter.cancel()
          }
        }
      } catch (e: Throwable) {
        requestChannel.cancel(CancellationException("Could not write message", e))
        if (e !is IOException && e !is CancellationException) {
          throw e
        }
      }
    }
    call.enqueue(object : Callback {
      override fun onFailure(call: Call, e: IOException) {
        // Something broke. Kill the response channel.
        responseChannel.close(e)
      }

      override fun onResponse(call: Call, response: GrpcResponse) {
        runBlocking {
          response.use {
            response.messageSource(method.responseAdapter).use { reader ->
              var exception: Exception? = null
              try {
                while (true) {
                  val message = reader.read() ?: break
                  responseChannel.send(message)
                }
                exception = response.grpcResponseToException()
              } catch (e: IOException) {
                exception = response.grpcResponseToException(e)
              } catch (e: Exception) {
                exception = e
              } finally {
                try {
                  responseChannel.close(exception)
                } catch (_: CancellationException) {
                  // If it's already canceled, there's nothing more to do.
                }
              }
            }
          }
        }
      }
    })

    return requestChannel to responseChannel
  }
}
