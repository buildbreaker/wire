// Code generated by Wire protocol buffer compiler, do not edit.
// Source: buf.connect.demo.eliza.v1.ElizaService in simple.proto
package buf.connect.demo.eliza.v1

import com.squareup.wire.GrpcMethod
import com.squareup.wire.GrpcResponse
import com.squareup.wire.internal.GrpcMessageSource
import com.squareup.wire.internal.grpcResponseToException
import com.squareup.wire.internal.newDuplexRequestBody
import com.squareup.wire.toHttpUrl
import java.io.IOException
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.channels.consumeEach
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import okhttp3.Call
import okhttp3.Callback
import okhttp3.Request
import okio.Buffer

/**
 * ElizaService provides a way to talk to the ELIZA, which is a port of
 * the DOCTOR script for Joseph Weizenbaum's original ELIZA program.
 * Created in the mid-1960s at the MIT Artificial Intelligence Laboratory,
 * ELIZA demonstrates the superficiality of human-computer communication.
 * DOCTOR simulates a psychotherapist, and is commonly found as an Easter
 * egg in emacs distributions.
 */
public class GrpcElizaServiceClient constructor(
  private val client: Call.Factory,
  private val baseUrl: String
) : ElizaServiceClient {

  fun converse(scope: CoroutineScope): Pair<SendChannel<ConverseRequest>, ReceiveChannel<ConverseResponse>> {
    val method = GrpcMethod(
      path = "/buf.connect.demo.eliza.v1.ElizaService/Converse",
      requestAdapter = ConverseRequest.ADAPTER,
      responseAdapter = ConverseResponse.ADAPTER
    )
    val requestChannel = Channel<ConverseRequest>(1)
    val responseChannel = Channel<ConverseResponse>(1)
    val requestBody = newDuplexRequestBody()
    val requestMetadata = emptyMap<String, String>()
    val call = client.newCall(
      Request.Builder()
        .url(baseUrl.toHttpUrl().resolve(method.path)!!.toUrl())
        .addHeader("te", "trailers")
        .addHeader("grpc-trace-bin", "")
        .addHeader("grpc-accept-encoding", "gzip")
        .apply {
//          if (client.minMessageToCompress < Long.MAX_VALUE) {
//            addHeader("grpc-encoding", "gzip")
//          }
          for ((key, value) in requestMetadata) {
            addHeader(key, value)
          }
        }
        .tag(GrpcMethod::class.java, method)
        .method("POST", requestBody)
        .build()
    )

    responseChannel.invokeOnClose {
      if (responseChannel.isClosedForReceive) {
        // Short-circuit the request stream if it's still active.
        call.cancel()
        requestChannel.cancel()
      }
    }
    scope.launch(Dispatchers.IO) {
      val sink = requestBody.createSink()
      try {
        sink.use {
          var channelReadFailed = true
          try {
            requestChannel.consumeEach { message ->
              channelReadFailed = false
              val encodedMessage = Buffer()
              method.requestAdapter.encode(encodedMessage, message)
              val buffer = Buffer()
              buffer.writeByte(0)
              buffer.writeInt(encodedMessage.size.toInt())
              buffer.writeAll(encodedMessage)
              sink.writeAll(buffer)
              sink.flush()
              channelReadFailed = true
            }
            channelReadFailed = false
          } finally {
            if (channelReadFailed) call.cancel()
          }
        }
      } catch (e: Throwable) {
        requestChannel.cancel(CancellationException("Could not write message", e))
        if (e !is IOException && e !is CancellationException) {
          throw e
        }
      }
    }
    call.enqueue(object : Callback {
      override fun onFailure(call: Call, e: IOException) {
        // Something broke. Kill the response channel.
        responseChannel.close(e)
      }

      override fun onResponse(call: Call, response: GrpcResponse) {
        runBlocking {
          response.use {
            response.body!!.source().use { reader ->
              var exception: Exception? = null
              try {
                while (true) {
                  if (reader.exhausted()) break
                  reader.readByte()
                  val length = reader.readInt().toLong() and 0xffffffffL
                  val encodedMessage = Buffer().write(reader, length)
                  val message = encodedMessage.use { buffer ->
                    method.responseAdapter.decode(buffer)
                  }
                  responseChannel.send(message)
                }
                exception = response.grpcResponseToException()
              } catch (e: IOException) {
                exception = response.grpcResponseToException(e)
              } catch (e: Exception) {
                exception = e
              } finally {
                try {
                  responseChannel.close(exception)
                } catch (_: CancellationException) {
                  // If it's already canceled, there's nothing more to do.
                }
              }
            }
          }
        }
      }
    })



    return requestChannel to responseChannel
  }
}
